import { NextRequest, NextResponse } from 'next/server'
import { getServerSession } from 'next-auth'
import { authOptions } from '@/lib/auth'
import { prisma } from '@/lib/prisma'
import PDFDocument from 'pdfkit'
import { format, startOfWeek, endOfWeek } from 'date-fns'

export const dynamic = 'force-dynamic'
export const runtime = 'nodejs'

// GET - Export supplement tracker report as PDF
export async function GET(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions)
    if (!session?.user?.id) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const { searchParams } = new URL(request.url)
    const weekStartParam = searchParams.get('weekStart')
    const userId = searchParams.get('userId') || session.user.id

    // Only allow viewing own entries unless Super Admin/Owner
    const canViewAll = session.user.role === 'Super Admin' || session.user.role === 'Owner'
    const targetUserId = canViewAll && searchParams.get('userId') ? searchParams.get('userId') : session.user.id

    const where: any = { userId: targetUserId }

    // Filter by week: use date-only (UTC midnight) so comparison matches @db.Date storage
    if (weekStartParam) {
      const weekStart = new Date(weekStartParam.trim() + 'T00:00:00.000Z')
      if (isNaN(weekStart.getTime())) {
        return NextResponse.json({ error: 'Invalid weekStart date' }, { status: 400 })
      }
      where.weekStartDate = weekStart
    }

    const entries = await prisma.supplementTracker.findMany({
      where,
      orderBy: { createdAt: 'desc' },
      include: {
        user: {
          select: {
            id: true,
            name: true,
            email: true,
          },
        },
      },
    })

    if (entries.length === 0) {
      return NextResponse.json({ error: 'No entries found to export' }, { status: 404 })
    }

    // Calculate totals
    const totals = entries.reduce(
      (acc, entry) => ({
        totalOriginal: acc.totalOriginal + entry.originalAmount,
        totalSupplement: acc.totalSupplement + entry.supplementAmount,
        totalFinal: acc.totalFinal + entry.finalAmount,
      }),
      { totalOriginal: 0, totalSupplement: 0, totalFinal: 0 }
    )

    // Generate PDF
    const pdfBuffer = await generateSupplementPDF({
      entries,
      totals,
      userName: session.user.name ?? session.user.email ?? 'User',
      weekStart: weekStartParam ? new Date(weekStartParam) : null,
    })

    const pdfArray = new Uint8Array(pdfBuffer)
    const fileName = weekStartParam
      ? `Supplement_Tracker_${format(new Date(weekStartParam), 'yyyy-MM-dd')}.pdf`
      : `Supplement_Tracker_${format(new Date(), 'yyyy-MM-dd')}.pdf`

    return new NextResponse(pdfArray, {
      status: 200,
      headers: {
        'Content-Type': 'application/pdf',
        'Content-Disposition': `attachment; filename="${fileName}"`,
      },
    })
  } catch (error: unknown) {
    // Client disconnected (navigated away, refreshed, or cancelled) â€” don't log as error
    const err = error as NodeJS.ErrnoException & { code?: string } | undefined
    if (err?.code === 'ECONNRESET' || (error instanceof Error && error.message === 'aborted')) {
      return new NextResponse(null, { status: 499 })
    }
    const message = error instanceof Error ? error.message : 'Failed to generate PDF'
    console.error('[Supplement Tracker Export] Error:', error)
    return NextResponse.json({ error: message }, { status: 500 })
  }
}

interface PDFData {
  entries: Array<{
    id: string
    customerName: string
    claimNumber: string
    originalAmount: number
    supplementAmount: number
    finalAmount: number
    weekStartDate: Date
    notes: string | null
    createdAt: Date
    user: {
      id: string
      name: string | null
      email: string
    }
  }>
  totals: {
    totalOriginal: number
    totalSupplement: number
    totalFinal: number
  }
  userName: string
  weekStart: Date | null
}

async function generateSupplementPDF(data: PDFData): Promise<Buffer> {
  return new Promise((resolve, reject) => {
    try {
      const doc = new PDFDocument({
        margin: 50,
        size: 'LETTER',
      })

      const buffers: Buffer[] = []

      doc.on('data', buffers.push.bind(buffers))
      doc.on('end', () => {
        const pdfBuffer = Buffer.concat(buffers)
        resolve(pdfBuffer)
      })
      doc.on('error', reject)

      // Header
      doc
        .fontSize(20)
        .font('Helvetica-Bold')
        .fillColor('#dc2626')
        .text('Supplement Tracker Report', { align: 'center' })
        .moveDown(0.5)

      // Report Info
      doc
        .fontSize(12)
        .font('Helvetica')
        .fillColor('#000000')
        .text(`Generated by: ${data.userName}`, { align: 'left' })
        .text(`Date: ${format(new Date(), 'MMM d, yyyy')}`, { align: 'left' })

      if (data.weekStart) {
        const weekEnd = endOfWeek(data.weekStart, { weekStartsOn: 1 })
        doc.text(
          `Week: ${format(data.weekStart, 'MMM d, yyyy')} - ${format(weekEnd, 'MMM d, yyyy')}`,
          { align: 'left' }
        )
      }

      doc.text(`Total Entries: ${data.entries.length}`, { align: 'left' }).moveDown(1)

      // Summary Section
      doc
        .fontSize(16)
        .font('Helvetica-Bold')
        .fillColor('#dc2626')
        .text('Summary Totals', { underline: true })
        .moveDown(0.5)

      doc
        .fontSize(11)
        .font('Helvetica')
        .fillColor('#000000')
        .text(`Total Original Amount: $${data.totals.totalOriginal.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}`, {
          indent: 20,
        })
        .text(`Total Actual Supplement: $${data.totals.totalSupplement.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}`, {
          indent: 20,
        })
        .font('Helvetica-Bold')
        .fillColor('#dc2626')
        .text(`Total After Supplement: $${data.totals.totalFinal.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}`, {
          indent: 20,
        })
        .fillColor('#000000')
        .moveDown(1)

      // Entries Table
      doc
        .fontSize(16)
        .font('Helvetica-Bold')
        .fillColor('#dc2626')
        .text('Supplement Entries', { underline: true })
        .moveDown(0.5)

      // Table header
      const headerY = doc.y
      doc
        .fontSize(9)
        .font('Helvetica-Bold')
        .fillColor('#000000')
        .text('Customer', 50, headerY, { width: 120 })
        .text('Claim #', 170, headerY, { width: 100 })
        .text('Original', 270, headerY, { width: 80 })
        .text('Actual Supp.', 350, headerY, { width: 80 })
        .text('After Supp.', 430, headerY, { width: 80 })
        .text('Date', 510, headerY, { width: 60 })

      let yPos = headerY + 15
      doc.moveTo(50, yPos).lineTo(570, yPos).stroke()

      // Entries rows
      data.entries.forEach((entry) => {
        if (doc.y > 700) {
          doc.addPage()
          yPos = 50
        }

        yPos = doc.y + 10

        doc
          .fontSize(8)
          .font('Helvetica')
          .fillColor('#000000')
          .text(entry.customerName.substring(0, 18) + (entry.customerName.length > 18 ? '...' : ''), 50, yPos, {
            width: 120,
          })
          .text(entry.claimNumber.substring(0, 12) + (entry.claimNumber.length > 12 ? '...' : ''), 170, yPos, {
            width: 100,
          })
          .text(`$${entry.originalAmount.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}`, 270, yPos, {
            width: 80,
          })
          .text(`$${entry.supplementAmount.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}`, 350, yPos, {
            width: 80,
          })
          .text(`$${entry.finalAmount.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}`, 430, yPos, {
            width: 80,
          })
          .text(format(new Date(entry.createdAt), 'MM/dd/yy'), 510, yPos, { width: 60 })

        yPos += 15
        doc.moveTo(50, yPos).lineTo(570, yPos).stroke()
      })

      // Footer
      const pageInfo = doc.bufferedPageRange()
      if (pageInfo) {
        const totalPages = pageInfo.count
        const currentPage = pageInfo.start + 1
        doc
          .fontSize(8)
          .font('Helvetica')
          .fillColor('#666666')
          .text(
            `Page ${currentPage} of ${totalPages} | Generated by Manny's ToolBox`,
            50,
            doc.page.height - 30,
            { align: 'center', width: 500 }
          )
      }

      doc.end()
    } catch (error) {
      reject(error)
    }
  })
}
